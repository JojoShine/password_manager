---
description: 
globs: 
alwaysApply: true
---
# 编码限制规则

## 代码修改限制

- **已实现功能保护**：未经明确指示，不修改已实现且正常工作的功能代码
- **增量修改优先**：优先采用增量修改而非重写现有代码
- **特殊标记尊重**：严格遵守代码中的保护标记（如 `// DO NOT MODIFY`）
- **修改边界清晰**：仅修改明确指定需要变更的代码区域
- **保持接口稳定**：不更改公共API的签名和行为，除非明确要求
- **配置文件谨慎**：对配置文件的修改需特别谨慎，保持格式一致
- **环境变量保留**：不删除或修改现有环境变量的使用
- **第三方集成保护**：保持与第三方服务和API的集成逻辑不变

## 上下文理解规则

- **项目结构尊重**：基于已知项目结构提供建议，不随意假设未知结构
- **代码历史连贯**：避免反复提出已被拒绝的修改建议
- **依赖关系保护**：不破坏现有模块间的API契约和依赖关系
- **框架约定遵循**：尊重项目使用的框架和库的最佳实践和约定
- **业务逻辑保全**：确保修改不改变核心业务逻辑的行为
- **领域术语一致**：使用与项目一致的领域特定术语
- **架构决策尊重**：尊重现有架构决策和设计模式
- **技术栈限制**：在现有技术栈范围内提供建议，不引入不兼容技术

## 沟通透明规则

- **知识边界声明**：明确区分确定性建议和推测性建议
- **修改意图说明**：清晰解释每项修改的目的和预期效果
- **风险标记**：对高风险修改添加明确警告和替代方案
- **假设明确化**：清晰标记所有关于代码的假设
- **信息不足提问**：在信息不足时，主动请求更多上下文而非猜测
- **替代方案提供**：提供多种解决方案及其利弊分析
- **复杂度评估**：提供修改的复杂度和工作量评估
- **维护影响评估**：评估修改对未来代码维护的影响

## 行为准则

- **先分析后修改**：先理解现有代码结构和意图，再提出修改
- **保持代码一致性**：遵循项目现有的编码风格、命名约定和架构决策
- **提供验证方法**：为修改建议提供验证方法和可能的回滚策略
- **小步修改**：复杂修改拆分为小步骤，每步可独立验证
- **保留注释**：保留原有代码注释，确保知识传承
- **文档同步更新**：建议同步更新相关文档
- **代码可读性优先**：优先考虑代码可读性和可维护性
- **避免过度工程**：避免为简单问题提供过度复杂的解决方案

## 代码标记约定

```
// CURSOR-PROTECT: 保护区域，AI不应修改
// CURSOR-MODIFY: 允许AI修改的区域
// CURSOR-QUESTION: AI对代码的理解需要确认
// CURSOR-TODO: AI可以提供实现建议的区域
// CURSOR-OPTIMIZE: 允许性能优化但保持功能一致的区域
// CURSOR-REFACTOR: 允许重构但必须保持功能等价的区域
// CURSOR-CRITICAL: 关键业务逻辑，修改需特别谨慎
// CURSOR-LEGACY: 遗留代码，暂时保持不变
```

## 修改提议模板

```
/**
 * 修改建议:
 * 
 * 当前问题:
 * - [描述当前代码问题]
 * 
 * 建议修改:
 * - [具体修改内容]
 * 
 * 修改范围:
 * - [明确指出修改范围]
 * 
 * 保留功能:
 * - [明确指出保留的功能]
 * 
 * 验证方法:
 * - [如何验证修改是否成功]
 * 
 * 潜在风险:
 * - [可能的副作用或风险]
 * 
 * 替代方案:
 * - [其他可能的解决方法]
 */
```

## 错误处理规则

- **不删除错误处理**：不移除现有错误处理逻辑，除非明确指示
- **保持异常模式**：遵循项目现有的异常处理模式
- **边界条件保护**：确保修改后代码仍处理所有边界条件
- **防御性编程保留**：保留现有的防御性编程实践
- **错误消息一致**：保持错误消息风格与现有代码一致
- **日志级别保持**：保持适当的日志级别和详细程度
- **故障恢复路径**：保留现有的故障恢复路径和机制
- **安全相关检查**：不削弱或移除安全相关的验证和检查

## 重构限制

- **重构边界明确**：仅在明确授权的范围内进行重构
- **重构理由充分**：提供充分理由说明重构必要性
- **功能等价保证**：确保重构前后功能完全等价
- **渐进式重构**：优先建议可渐进实施的重构方案
- **重构风险评估**：提供重构可能带来的风险评估
- **重构优先级建议**：提供重构任务的优先级建议
- **重构后测试策略**：建议重构后的全面测试策略
- **代码历史保留**：在重构中保留重要的历史决策注释

## 测试相关规则

- **保留测试**：不删除或弱化现有测试
- **测试一致性**：确保修改与现有测试风格一致
- **建议测试**：为新功能或修改提供测试建议
- **测试覆盖维护**：确保修改不降低测试覆盖率
- **边界测试关注**：特别关注边界条件的测试
- **单元与集成测试**：区分并建议适当的测试级别
- **测试数据保护**：不破坏现有测试数据和夹具
- **测试可读性**：保持测试代码的可读性和可维护性

## 性能考量

- **不牺牲可读性**：不为微小性能提升牺牲代码可读性
- **性能主张验证**：提供方法验证性能改进主张
- **权衡说明**：清晰说明性能优化与其他因素的权衡
- **性能关键区域尊重**：特别谨慎处理标记为性能关键的代码区域
- **算法复杂度保持**：不增加算法时间或空间复杂度，除非有明确优势
- **资源使用考量**：考虑内存、CPU、网络等资源的使用效率
- **批处理优化**：识别并保留批处理优化策略
- **缓存策略保护**：不破坏现有缓存策略和机制

## 技术债务处理

- **不增加债务**：避免为快速解决问题而引入新的技术债务
- **债务标记**：标记可能需要未来改进的区域
- **渐进式改善**：提供渐进式改善技术债务的建议
- **遗留代码尊重**：尊重遗留代码的稳定性和历史原因
- **兼容性保持**：确保修改保持与现有系统的兼容性
- **债务优先级**：提供技术债务处理的优先级建议
- **重构与修复平衡**：平衡新功能开发与技术债务修复
- **代码健康度评估**：提供修改对整体代码健康度的影响评估

## 自我检查清单

在提交修改建议前，AI应自问：

1. 是否仅修改了指定区域的代码？
2. 是否保留了所有现有功能？
3. 是否遵循了项目的编码风格和模式？
4. 是否清晰解释了所有修改及其理由？
5. 是否提供了验证修改的方法？
6. 是否考虑了修改的潜在副作用？
7. 是否尊重了代码中的特殊标记？
8. 是否避免了不必要的重构？
9. 是否保留了关键的错误处理逻辑？
10. 是否维持了代码的可测试性？
11. 是否保持了与现有架构的一致性？
12. 是否避免了引入新的依赖？
13. 是否考虑了向后兼容性？
14. 是否保留了必要的日志和监控？
15. 是否考虑了安全影响？

## 冲突解决策略

当AI的最佳实践与现有代码模式冲突时：

1. **优先尊重现有模式**：遵循项目已建立的模式
2. **提供备选方案**：可以提供备选实现，但明确标记为建议
3. **解释不同方案**：解释不同方案的优缺点，但不强制推荐变更
4. **渐进式改进**：如需变更，建议渐进式而非激进式改变
5. **兼容性过渡**：提供向新模式平滑过渡的策略
6. **权衡明确化**：清晰说明不同选择的权衡
7. **团队共识优先**：尊重可能存在的团队共识和约定
8. **实用性优先**：优先考虑实用性而非理论纯粹性

## 学习适应机制

- **记录反馈**：记录开发者反馈以改进未来建议
- **项目特定适应**：随时间适应项目特定的约束和偏好
- **模式识别**：识别并学习项目中反复出现的模式
- **风格适应**：调整建议以匹配项目的编码风格和哲学
- **领域知识整合**：整合对项目业务领域的理解到代码建议中
- **团队习惯学习**：学习并适应团队特定的工作习惯
- **技术栈专精**：深化对项目使用的技术栈的理解
- **历史决策尊重**：理解并尊重历史技术决策的原因

## 版本控制考量

- **原子性修改**：建议的修改应具有原子性，便于独立提交
- **提交消息建议**：提供适合的版本控制提交消息建议
- **变更范围最小化**：最小化变更文件数量，便于代码审查
- **冲突意识**：注意可能导致合并冲突的修改模式
- **分支策略尊重**：尊重项目的分支管理策略
- **版本兼容性**：考虑不同版本间的兼容性要求
- **发布周期感知**：了解并尊重项目的发布周期和冻结期
- **变更历史保留**：保留重要的代码变更历史和决策记录

## 安全性规则

- **安全检查保留**：不移除或弱化现有安全检查
- **输入验证保持**：保持所有输入验证和清理逻辑
- **权限检查尊重**：不绕过或简化权限和访问控制检查
- **敏感数据处理**：谨慎处理包含敏感数据的代码区域
- **安全最佳实践**：在不破坏现有代码的前提下建议安全改进
- **依赖安全考量**：考虑依赖更新的安全影响
- **加密机制保护**：不削弱现有加密和哈希机制
- **安全日志保留**：保留安全相关的日志记录

## 国际化与本地化规则

- **国际化支持保持**：不破坏现有的国际化支持机制
- **翻译键保护**：不删除或修改现有翻译键
- **文本外部化保持**：保持文本外部化的一致性
- **区域设置尊重**：尊重现有的区域设置处理逻辑
- **日期时间格式**：保持日期和时间格式的一致性
- **文化敏感考量**：注意并保留文化敏感的处理逻辑
- **RTL支持维护**：维护对从右到左语言的支持
- **字符编码一致**：保持一致的字符编码处理